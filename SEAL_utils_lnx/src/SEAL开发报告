基于SEAL的函数运算工具集 开发报告
作者：G3 解天行

一：程序内容
	（一）：核心功能：实现了基于SEAL库同态加密技术的超越函数运算，包括lnx,sinx,cosx,exp。
	（二）：程序算法：
		1.lnx: 将输入数据预先处理为x=m*2^i形式，其中i为整数。后续在加密状态下计算对数时就有：lnx=lnm+iln2。ln2是事先预置好的数值，lnm使用lnx在x=1处的泰勒展开计算，提供至多五项展开。
		2.sinx&cosx：将输入数据预先规约到[-pai/2,pai/2]之中，然后在加密状态下使用多项式a1+a2x+a3x^2……拟合数据。其中系数a1,a2等通过雷米兹算法得到，至多提供5项展开
		3.exp:将数据预先处理为x=m^4^i的形式，其中i是整数。随后在加密状态下利用多项式拟合exp(m)，拟合多项式的形式和系数的计算方法与三角函数相同。将结果解密后，计算exp(m)^4^i得到最终结果
	(三）： 程序结构：程序由src中的main函数，以及include中的utils.h与nlopt.h组成。
			main函数提供数据的输入和预先处理。
			utils.h中包含utils类，实现了核心功能，即对数据的加密、运算、输出、以及误差分析
			nlopt.h提供了一个估算系数的函数，与运算本身无直接联系
			运行顺序：输入-->main-->utils.h-->输出
			包含关系：utils.h--(link to)-->main
						      ^
						      |
				 nlopt.h--(link to)---+
二：开发过程问题总结
	（一）：SEAL库安装阶段：
		1.SEAL库在从github上下载之后，#include"seal/seal.h"提示找不到库-->SEAL库安装后需要自行编译
		2.CMAKELIST提示找不到库-->怀疑路径错误，使用${}来自动查找路径
		3.SEAL计算出现误差-->可能原因：系数模数配置不正确-->检查系数模数的大小和数量。最大和最小系数模数的数值差距在20左右为佳，头尾两端系数模数推荐偏大且不低于50；
					     系数模数与缩放因子不匹配-->如果系数模数中间数的大小为a,推荐缩放因子大小为2^a；
					     计算的数据过大，SEAL库自行截断数据-->调整系数模数的大小。如果系数模数达到最大值依然出现截断，考虑选择使用更小数据的计算方式；
					  计算过程中阶数过高，连续乘法导致小误差被放大（在12次方的密文计算下，误差可能被放大2～3个数量级）-->更换计算方式；
					  计算过程中缺少rescale步骤或过渡使用mod_switch_to_implace步骤
	（二）：报错称scale out of bounds:往往是计算深度不足-->检查系数模数链配置，适当增加其长度
	（三）：报错称encrypted is not valid for encryption parameters：往往是加密了无效数据-->检查被加密数据是否为空
	（四）：报错称encrypted1 and encrypted2 parameter mismatch：往往是模数转换链索引不匹配-->可以使用context.get_context_data(encrypted.parms_id())->chain_index打印对应明文/密文的模数转换链索引进行对比检查
	（五）：报错称重线性化密钥长度不足：可能遗漏重线性化步骤，检查所有的密文乘法步骤
	（六）：报错称encryption parameters are not set correctly：系数模数之和超出多项式模数大小限制-->减少系数模数大小或数量/增加多项式模数
	（七）：segmentation fault:程序逻辑错误:往往不错在加密运算的部分。常见的原因包括循环向vector中输入数据时，忘记实现规定vector的大小并使用array[i]的形式输入数据
	（八）：具体函数报错：往往是函数参数错误-->自行调整	
个人遇到的具体问题：	
共用函数导致解密报错：在decrypt_result中：当kind==1设计了一个反转操作。这本来是给指数函数准备的，但是在计算的过程中对数函数也存在kind==1的情况，这导致了不必要的翻转，致使结果出现极大误差。
三角函数选择系数文件行数出错：额外乘了一个10导致系数串行
		
		
